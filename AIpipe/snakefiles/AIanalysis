#!/usr/bin/env python3

import pandas as pd
import os

## Load config file
configfile: "config/config_AIanalysis.yaml"

## Read in RNA-seq samplesheet
samples = pd.read_csv(config["samplesheet"],sep=",")

## Convert samplesheet columns to strings
samples = samples.astype(str)

## Concatenate Sequencing_Directory to Read1 and Read2 for full read paths
samples['Read1'] = samples[['Sequencing_Directory', 'Read1']].apply(lambda row: os.path.join(*row), axis=1)
samples['Read2'] = samples[['Sequencing_Directory', 'Read2']].apply(lambda row: os.path.join(*row), axis=1)

## Group Seq_Reps
samples['id'] = samples[['Proj', 'Donor', 'Condition', 'Time', 'Tech_Rep']].agg('_'.join, axis=1)

## Extract grouped read1 and read2s
read1 = samples.groupby(['id'])['Read1'].apply(list).to_dict()
read2 = samples.groupby(['id'])['Read2'].apply(list).to_dict()

## Get vcf file path of VCFproc processed vcf from config file
vcf = config['vcf']
vcf_prefix = config['vcf_prefix']

onsuccess:
    print("Allelic imbalance analysis workflow finished successfully!")

onerror:
    print("An error occurred in the allelic imbalance analysis workflow. Deleting weightMatrix. Try updating the `weightVal` parameter and rerun.")
    # Removing current weightMatrix
    #os.remove('output/AI/weightMatrix.txt')


rule all:
    input:
        'output/AI/differentialAllelicImbalance.rda',
        'output/AI/agreementReport.txt',
        'output/AI/AI_variant_positions.txt'

rule overlapVariants:
    input:
        [expand("output/{group}/alleleCounts/{group}_alleleCounts.csv", group = key) for key in read1]
    output:
        [expand("output/{group}/alleleCounts/{group}_commonCounts.csv", group = key) for key in read1],
        "output/vcf/commonSnps.txt"
    log:
        out = "output/vcf/logs/overlapVariants.out"
    shell:
        """
        module load r/4.1.0
        Rscript scripts/overlapVariants.r {input} 1> {log.out}
        """

rule VCFoverlapSamples:
    input:
        'output/vcf/' + vcf_prefix + '_ALL_qc_nodups_biallelic.vcf.gz',
    output:
        temp('output/vcf/AIsamples.txt'),
        'output/vcf/' + vcf_prefix + '_ALL_qc_nodups_biallelic_samples.vcf.gz'
    params:
        donors = ",".join(samples['Donor'].unique().tolist()),
        donorConversions = config['donors'],
        prefix = vcf_prefix
    threads: 4
    log:
        err = "output/vcf/logs/removeDuplicates.err"
    shell:
        """
        module load r/4.1.0
        Rscript scripts/convertDonors.r {params.donors} {params.donorConversions}

        module load samtools
        bcftools view -S output/vcf/AIsamples.txt --threads {threads} -o output/vcf/{params.prefix}_ALL_qc_nodups_biallelic_samples.vcf {input} 2> {log.err}
        
        bgzip output/vcf/{params.prefix}_ALL_qc_nodups_biallelic_samples.vcf
        """

rule VCFoverlapVariants:
    input:
        vcf = 'output/vcf/' + vcf_prefix + '_ALL_qc_nodups_biallelic_samples.vcf.gz',
        snps = "output/vcf/commonSnps.txt"
    output:
        "output/vcf/" + vcf_prefix + "_ALL_qc_nodups_biallelic_AI.recode.vcf.gz"
    params:
        prefix = "output/vcf/" + vcf_prefix + "_ALL_qc_nodups_biallelic_AI"
    shell:
        """
        module load vcftools
        module load samtools
        vcftools --gzvcf {input.vcf} --snps {input.snps} --recode --recode-INFO-all --out {params.prefix}
        bgzip {params.prefix}.recode.vcf   
        """

rule VCFoverlapVariantsIndex:
    input:
        rules.VCFoverlapVariants.output
    output:
        "output/vcf/" + vcf_prefix + "_ALL_qc_nodups_biallelic_AI.recode.vcf.gz.tbi"
    log:
        out = "output/vcf/logs/overlapVariantsIndex.out",
        err = "output/vcf/logs/overlapVariantsIndex.err"
    shell:
        """
        module load gatk/4.1.7.0
        gatk IndexFeatureFile -I {input} 2> {log.err} 1> {log.out}
        """

rule concatAlleleCounts:
    input:
        [expand("output/{group}/alleleCounts/{group}_commonCounts.csv", group = key) for key in read1]
    output:
        'output/AI/alleleCountsMatrix.txt',
        'output/AI/colData.txt'
    params:
        donors = ",".join(samples['Donor'].unique().tolist()),
        conditions = ",".join(samples['Condition'].unique().tolist())
    log:
        out = "output/AI/logs/concatAlleleCounts.out"
    shell:
        """
        module load r/4.1.0
        mkdir -p output/AI/logs
        Rscript scripts/concatAlleleCounts.r {params.donors} {params.conditions} {input} 1> {log.out}
        """

rule getRNAHets:
    input:
        'output/AI/alleleCountsMatrix.txt'
    output:
        'output/AI/RNAhets.csv'
    params:
        donors = ",".join(samples['Donor'].unique().tolist()),
        minTotalAlleleCounts = config['minTotalAlleleCounts'],
        minAlleleCounts = config['minAlleleCounts']
    log:
        out = "output/AI/logs/rnaHets.out"
    shell:
        """ 
        python3 scripts/rnaHets.py {input} {params.donors} {params.minTotalAlleleCounts} {params.minAlleleCounts} 1> {log.out}
        """
         
rule getGenoHets:
    input:
        vcf = rules.VCFoverlapVariants.output,
        index = rules.VCFoverlapVariantsIndex.output
    output:
        'output/AI/genohets.csv'
    params:
        donorConversions = config['donors']
    log:
        out = "output/AI/logs/genoHets.out"
    shell:
        """
        python3 scripts/genoHets.py {input.vcf} {params.donorConversions} 1> {log.out}
        """

rule reportAgreement:
    input:
        rna = rules.getRNAHets.output,
        geno = rules.getGenoHets.output
    output:
        'output/AI/agreementReport.txt'
    shell:
        """
        python3 scripts/checkAgreement.py {input.geno} {input.rna} 1> {output}
        """

rule checkConcordance:
    input:
        rna = rules.getRNAHets.output,
        geno = rules.getGenoHets.output
    output:
        'output/AI/removeVariants.csv'
    log:
        out = "output/AI/logs/checkConcordance.out"
    params: 
        minHets = config['minHets']
    threads: 4
    shell:
        """
        # joblib module needs this version of python3
        module load python/3.9.6
        python3 scripts/checkConcordance.py {input.geno} {input.rna} {params.minHets} 1> {log.out}
        """

rule filterVariants:
    input:
        matrix = 'output/AI/alleleCountsMatrix.txt',
        filter = rules.checkConcordance.output,
        rna = rules.getRNAHets.output
    output:
        'output/AI/alleleCountsMatrix_filtered.txt',
        'output/AI/RNAhets_filtered.txt'
    log:
        out = 'output/AI/logs/filterVariants.out'
    shell:
        """
        module load r/4.1.0
        Rscript scripts/filterVariants.r {input.matrix} {input.filter} {input.rna} 1> {log.out}
        """

rule buildWeightsMatrix:
    input:
        matrix = 'output/AI/alleleCountsMatrix_filtered.txt',
        hets = 'output/AI/RNAhets_filtered.txt'
    output:
        'output/AI/weightMatrix.txt'
    log:
        out = 'output/AI/logs/buildWeightsMatrix.out'
    params:
        weightVal = config['weightVal']
    threads: 4
    shell:
        """
        module load python/3.9.6
        python3 scripts/buildWeightsMatrix.py {input.matrix} {input.hets} {params.weightVal} 1> {log.out}
        """

rule runDifferentialAnalysis:
    input:
        counts = 'output/AI/alleleCountsMatrix_filtered.txt',
        colData = 'output/AI/colData.txt',
        weights = 'output/AI/weightMatrix.txt'
    output:
        'output/AI/differentialAllelicImbalance.rda',
        'output/AI/AI_variant_positions.txt'
    log:
        out = 'output/AI/logs/differentialAnalysis.out'
    params:
        weightVal = config['weightVal']
    shell:
        """
        module load r/4.1.3
        Rscript scripts/differentialAnalysis.r {input.counts} {input.colData} {input.weights} 1> {log.out}
        """
